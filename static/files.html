<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>File Transfer</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Socket.IO -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js"></script>
  <!-- CryptoJS for MD5 checksum -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <!-- Pako for compression/decompression -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <style>
    body { padding: 20px; }
    #status { margin-top: 1rem; font-weight: bold; }
    .progress { height: 20px; margin-bottom: 10px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>File Transfer</h1>
    
    <!-- Settings: These values would normally be fetched from /api/settings -->
    <div class="mb-3">
      <label for="senderCallsign" class="form-label">Your Callsign</label>
      <input type="text" id="senderCallsign" class="form-control" placeholder="Fetching your callsign...">
    </div>
    <div class="mb-3">
      <label for="receiverCallsign" class="form-label">Receiver Callsign (for sending)</label>
      <input type="text" id="receiverCallsign" class="form-control" placeholder="Enter receiver callsign">
    </div>
    <div class="mb-3">
      <label for="fileInput" class="form-label">File to Send</label>
      <input type="file" id="fileInput" class="form-control">
    </div>
    <!-- Removed the CRC checkbox -->

    <button id="sendFileBtn" class="btn btn-primary">Send File</button>
    <!-- New Cancel Button (initially hidden) -->
    <button id="cancelBtn" class="btn btn-secondary" style="display: none;">Cancel</button>
    <div id="status"></div>
    
    <hr>
    <h2>Sender Progress</h2>
    <div id="senderProgress">
      <p>No file being sent.</p>
    </div>
    
    <hr>
    <h2>Sent Files</h2>
    <div id="sentFiles">
      <p>No files sent yet.</p>
    </div>
    
    <hr>
    <h2>Receiver Progress</h2>
    <div id="receiverProgress">
      <p>No active transfers.</p>
    </div>
    
    <hr>
    <h2>Received Files</h2>
    <div id="receivedFiles">
      <p>No files received yet.</p>
    </div>
  </div>
  
  <!-- Bootstrap Bundle -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  
  <script>
    document.addEventListener("DOMContentLoaded", function() {

      /**********************************************************************
       * Utility Functions
       **********************************************************************/
      function padCallsign(cs) {
        return cs.toUpperCase().padEnd(9, ' ');
      }
      
      function uint8ToBase64(u8Arr) {
        const CHUNK_SIZE = 0x8000;
        let index = 0, result = '';
        const len = u8Arr.length;
        while (index < len) {
          const slice = u8Arr.subarray(index, Math.min(index + CHUNK_SIZE, len));
          result += String.fromCharCode.apply(null, slice);
          index += CHUNK_SIZE;
        }
        return btoa(result);
      }
      
      function base64ToUint8Array(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes;
      }
      
      // Generate a random 2-character file ID using case-sensitive alphanumerics.
      function generateFileId() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        return chars.charAt(Math.floor(Math.random() * chars.length)) +
               chars.charAt(Math.floor(Math.random() * chars.length));
      }
      
      /**********************************************************************
       * Persistence Functions for Sent & Received Files
       **********************************************************************/
      function saveReceivedFilesToLocalStorage(filesArray) {
        try {
          localStorage.setItem("receivedFiles", JSON.stringify(filesArray));
        } catch (e) {
          console.error("Error saving received files to localStorage:", e);
        }
      }
      
      function loadReceivedFilesFromLocalStorage() {
        const data = localStorage.getItem("receivedFiles");
        if (data) {
          try {
            return JSON.parse(data);
          } catch (e) {
            console.error("Error parsing received files from localStorage:", e);
          }
        }
        return [];
      }
      
      function saveSentFilesToLocalStorage(filesArray) {
        try {
          localStorage.setItem("sentFiles", JSON.stringify(filesArray));
        } catch (e) {
          console.error("Error saving sent files to localStorage:", e);
        }
      }
      
      function loadSentFilesFromLocalStorage() {
        const data = localStorage.getItem("sentFiles");
        if (data) {
          try {
            return JSON.parse(data);
          } catch (e) {
            console.error("Error parsing sent files from localStorage:", e);
          }
        }
        return [];
      }
      
      /**********************************************************************
       * UI Update Functions
       **********************************************************************/
      function updateReceivedFilesUI() {
        const container = document.getElementById('receivedFiles');
        if (persistentReceivedFiles.length === 0) {
          container.innerHTML = "<p>No files received yet.</p>";
          return;
        }
        let html = '<table class="table table-striped"><thead><tr><th>Date/Time</th><th>Sender</th><th>File Name</th><th>Original Size</th><th>Compressed Size</th><th>Size (decompressed)</th><th>Elapsed Time (s)</th><th>Speed (Bytes/s)</th><th>Duplicates</th><th>Checksum</th><th>Download</th><th>Delete</th></tr></thead><tbody>';
        persistentReceivedFiles.forEach((file, index) => {
          const checksumIcon = file.checksumMatch 
            ? '<span style="color:green;">&#10004;</span>' 
            : '<span style="color:red;">&#10008;</span>';
          const elapsedSec = file.elapsed / 1000;
          const speed = elapsedSec > 0 ? Math.floor((file.bytesReceived || file.size) / elapsedSec) : 0;
          const dupPercent = file.totalPackets ? Math.round((file.duplicates / file.totalPackets) * 100) : "0";
          html += `<tr>
                     <td>${new Date(file.timestamp).toLocaleString()}</td>
                     <td>${file.sender}</td>
                     <td>${file.fileName}</td>
                     <td>${file.originalSize} bytes</td>
                     <td>${file.compressedSize} bytes</td>
                     <td>${file.size} bytes</td>
                     <td>${(elapsedSec).toFixed(2)}</td>
                     <td>${speed}</td>
                     <td>${file.duplicates} (${dupPercent}%)</td>
                     <td>${checksumIcon}</td>
                     <td><button class="btn btn-success btn-sm" onclick="downloadReceivedFile(${index})">Download</button></td>
                     <td><button class="btn btn-danger btn-sm" onclick="deleteReceivedFile(${index})">Delete</button></td>
                   </tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      
      function updateSentFilesUI() {
        const container = document.getElementById('sentFiles');
        if (persistentSentFiles.length === 0) {
          container.innerHTML = "<p>No files sent yet.</p>";
          return;
        }
        let html = '<table class="table table-striped"><thead><tr><th>Date/Time</th><th>Receiver</th><th>File Name</th><th>Original Size</th><th>Compressed Size</th><th>Retries</th><th>Total Time (s)</th><th>Speed (Bytes/s)</th><th>Clear</th></tr></thead><tbody>';
        persistentSentFiles.forEach((stat, index) => {
          const totalTime = parseFloat(stat.totalTime);
          const speed = totalTime > 0 ? Math.floor(stat.bytesSent / totalTime) : 0;
          const retryPercent = stat.totalPackets ? Math.round(stat.totalRetries / stat.totalPackets * 100) : "0";
          html += `<tr>
                     <td>${new Date(stat.timestamp).toLocaleString()}</td>
                     <td>${stat.receiver || ""}</td>
                     <td>${stat.fileName}</td>
                     <td>${stat.originalSize} bytes</td>
                     <td>${stat.compressedSize} bytes</td>
                     <td>${stat.totalRetries} (${retryPercent}%)</td>
                     <td>${stat.totalTime}</td>
                     <td>${speed}</td>
                     <td><button class="btn btn-warning btn-sm" onclick="clearSentFile(${index})">Clear</button></td>
                   </tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      
      window.downloadReceivedFile = function(index) {
        const file = persistentReceivedFiles[index];
        if (!file) return;
        const a = document.createElement('a');
        a.href = file.dataUrl;
        a.download = file.fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      };
      
      window.deleteReceivedFile = function(index) {
        persistentReceivedFiles.splice(index, 1);
        saveReceivedFilesToLocalStorage(persistentReceivedFiles);
        updateReceivedFilesUI();
      };
      
      window.clearSentFile = function(index) {
        persistentSentFiles.splice(index, 1);
        saveSentFilesToLocalStorage(persistentSentFiles);
        updateSentFilesUI();
      };
      
      /**********************************************************************
       * Global Persistent Variables
       **********************************************************************/
      let persistentReceivedFiles = loadReceivedFilesFromLocalStorage();
      let persistentSentFiles = loadSentFilesFromLocalStorage();
      
      updateReceivedFilesUI();
      updateSentFilesUI();
      
      /**********************************************************************
       * Packet Building Functions
       *
       * Packet formats:
       * Header packet (seq === 1):
       *   sender(9) + ">" + receiver(9) + ":" + fileId(2) + ":" + seq(3) + "/" + totalChunks(3) + ":" + base64Data
       * Data packet (seq > 1):
       *   sender(9) + ">" + receiver(9) + ":" + fileId(2) + ":" + seq(3) + ":" + base64Data
       **********************************************************************/
      function buildPacket(sender, receiver, seq, totalChunks, payloadChunk, fileId) {
        const s = padCallsign(sender);
        const r = padCallsign(receiver);
        const seqStr = seq.toString().padStart(3, '0');
        const base64Data = uint8ToBase64(payloadChunk);
        let packet = "";
        if (seq === 1) {
          const totalStr = totalChunks.toString().padStart(3, '0');
          packet = s + '>' + r + ':' + fileId + ':' + seqStr + '/' + totalStr + ':' + base64Data;
        } else {
          packet = s + '>' + r + ':' + fileId + ':' + seqStr + ':' + base64Data;
        }
        if (packet.length > 255) {
          console.error("Packet size (" + packet.length + " bytes) exceeds 255 bytes. Consider reducing the chunk size.");
        }
        return packet;
      }
      
      // Build ACK packet without CRC.
      // Format:
      //   sender(9) + ">" + receiver(9) + ":" + fileId(2) + ":" + "ACK:" + seq(3)
      function buildAckPacket(ackSender, ackReceiver, fileId, seq) {
        const s = padCallsign(ackSender);
        const r = padCallsign(ackReceiver);
        const seqStr = seq.toString().padStart(3, '0');
        return s + '>' + r + ':' + fileId + ':' + "ACK:" + seqStr;
      }
      
      /**********************************************************************
       * Sender-Side Variables and Functions
       **********************************************************************/
      let currentFilePackets = [];
      let currentPacketIndex = 0;
      let currentRetries = 0;
      let totalRetries = 0;
      let fileTransferInProgress = false;
      let ackTimer = null;
      let sentFileStats = null;
      
      // Removed per‑chunk CRC flag
      
      function updateStatus(msg) {
        document.getElementById('status').innerText = msg;
        console.log(msg);
      }
      window.updateStatus = updateStatus;
      
      function updateSenderProgressUI() {
        const container = document.getElementById('senderProgress');
        const cancelBtn = document.getElementById('cancelBtn');
        if (!fileTransferInProgress || currentFilePackets.length === 0) {
          container.innerHTML = "<p>No file being sent.</p>";
          cancelBtn.style.display = "none";
          return;
        }
        cancelBtn.style.display = "inline-block";
        const now = Date.now();
        const elapsed = (now - sentFileStats.startTime) / 1000;
        const progressPercent = Math.floor((currentPacketIndex / currentFilePackets.length) * 100);
        let eta = "N/A";
        if (progressPercent > 0) {
          const estimatedTotal = elapsed / (progressPercent / 100);
          const remaining = estimatedTotal - elapsed;
          eta = remaining.toFixed(2) + " s";
        }
        const transferRate = elapsed > 0 ? sentFileStats.bytesSent / elapsed : 0;
        const retryPercent = currentFilePackets.length ? Math.round(totalRetries / currentFilePackets.length * 100) : 0;
        const html = `
          <h5>To ${sentFileStats.receiver} – ${sentFileStats.fileName} (ID: ${sentFileStats.fileId}) (${currentPacketIndex + 1}/${currentFilePackets.length} packets sent)</h5>
          <p>Original Size: ${sentFileStats.originalSize} bytes; Compressed Size: ${sentFileStats.compressedSize} bytes</p>
          <div class="progress">
            <div class="progress-bar" role="progressbar" style="width: ${progressPercent}%;" aria-valuenow="${progressPercent}" aria-valuemin="0" aria-valuemax="100">${progressPercent}%</div>
          </div>
          <p>Elapsed time: ${elapsed.toFixed(2)} s; ETA: ${eta} (${transferRate.toFixed(0)} bytes/sec); Retries: ${totalRetries} (${retryPercent}%)</p>
        `;
        container.innerHTML = html;
      }
      
      document.getElementById('cancelBtn').addEventListener('click', function() {
        if (fileTransferInProgress) {
          fileTransferInProgress = false;
          clearTimeout(ackTimer);
          updateStatus("File transfer canceled.");
          updateSenderProgressUI();
        }
      });
      
      function sendCurrentPacket(sender, receiver) {
        if (!fileTransferInProgress) return;
        if (currentPacketIndex >= currentFilePackets.length) {
          updateStatus("File transfer complete.");
          if (sentFileStats) {
            sentFileStats.endTime = Date.now();
            sentFileStats.totalTime = ((sentFileStats.endTime - sentFileStats.startTime) / 1000).toFixed(2);
            sentFileStats.totalRetries = totalRetries;
            sentFileStats.timestamp = sentFileStats.startTime;
            persistentSentFiles.push(sentFileStats);
            saveSentFilesToLocalStorage(persistentSentFiles);
            updateSentFilesUI();
            sentFileStats = null;
            totalRetries = 0;
          }
          fileTransferInProgress = false;
          updateSenderProgressUI();
          return;
        }
        updateSenderProgressUI();
        const packet = currentFilePackets[currentPacketIndex];
        if (!sentFileStats.bytesSent) {
          sentFileStats.bytesSent = 0;
        }
        sentFileStats.bytesSent += packet.length;
        updateStatus(`Sending packet ${currentPacketIndex + 1} of ${currentFilePackets.length} (Retry ${currentRetries})...`);
        socket.emit('send_raw', { packet: packet });
        ackTimer = setTimeout(() => {
          currentRetries++;
          totalRetries++;
          if (currentRetries <= 3) {
            updateStatus(`No ACK for packet ${currentPacketIndex + 1}. Retrying (${currentRetries}/3)...`);
            sendCurrentPacket(sender, receiver);
          } else {
            updateStatus(`Packet ${currentPacketIndex + 1} failed after 3 retries.`);
            fileTransferInProgress = false;
            updateSenderProgressUI();
          }
        }, 10000);
      }
      
      /**********************************************************************
       * Receiver-Side Variables and Functions
       **********************************************************************/
      const activeTransfers = {};
      
      function updateReceiverProgressUI() {
        const container = document.getElementById('receiverProgress');
        const keys = Object.keys(activeTransfers).filter(key => !activeTransfers[key].completed);
        if (keys.length === 0) {
          container.innerHTML = "<p>No active transfers.</p>";
          return;
        }
        container.innerHTML = "";
        keys.forEach(key => {
          const transfer = activeTransfers[key];
          const [sender, fileId] = key.split('_');
          const receivedCount = Object.keys(transfer.received).length;
          const total = transfer.totalChunks;
          const progressPercent = total ? Math.floor((receivedCount / total) * 100) : 0;
          let headerInfo = "";
          if (transfer.header) {
            headerInfo = ` - ${transfer.header.fileName} (ID: ${fileId})`;
          } else {
            headerInfo = ` (ID: ${fileId})`;
          }
          const elapsed = transfer.startTime ? ((Date.now() - transfer.startTime) / 1000) : 0;
          let eta = "N/A";
          if (progressPercent > 0) {
            const estimatedTotal = elapsed / (progressPercent / 100);
            const remaining = estimatedTotal - elapsed;
            eta = remaining.toFixed(2) + " s";
          }
          let bytesPerSec = "0";
          if (elapsed > 0 && transfer.rawBytesReceived) {
            bytesPerSec = (transfer.rawBytesReceived / elapsed).toFixed(0) + "";
          }
          const dupCount = transfer.duplicateCount || 0;
          const dupPercent = total ? Math.round((dupCount / total) * 100) : "0";
          let progressHTML = `<h5>From ${sender}${headerInfo} (${receivedCount}/${total || "?"} packets received)</h5>`;
          if (transfer.header) {
            progressHTML += `<p>Original Size: ${transfer.header.originalSize} bytes; Compressed Size: ${transfer.header.compressedSize} bytes</p>`;
          }
          progressHTML += `
            <div class="progress">
              <div class="progress-bar" role="progressbar" style="width: ${progressPercent}%;" aria-valuenow="${progressPercent}" aria-valuemin="0" aria-valuemax="100">${progressPercent}%</div>
            </div>
            <p>Elapsed time: ${elapsed.toFixed(2)} s; ETA: ${eta} (${bytesPerSec} bytes/sec); Duplicate receptions: ${dupCount} (${dupPercent}%)</p>`;
          let elem = document.getElementById('progress_' + key);
          if (!elem) {
            elem = document.createElement('div');
            elem.id = 'progress_' + key;
            container.appendChild(elem);
          }
          elem.innerHTML = progressHTML;
        });
      }
      
      function checkInactiveTransfers() {
        const now = Date.now();
        for (const key in activeTransfers) {
          if (activeTransfers.hasOwnProperty(key)) {
            const transfer = activeTransfers[key];
            if (now - transfer.lastUpdate > 30000) {
              console.log(`Transfer ${key} timed out due to 30 seconds of inactivity.`);
              delete activeTransfers[key];
              updateReceiverProgressUI();
            }
          }
        }
      }
      setInterval(checkInactiveTransfers, 1000);
      
      /**********************************************************************
       * Common Packet Processing Function
       *
       * ACK packet format:
       *   sender(9) + ">" + receiver(9) + ":" + fileId(2) + ":" + "ACK:" + seq(3)
       *
       * Data/Metadata packets:
       *   Header (seq === 1):
       *     sender(9) + ">" + receiver(9) + ":" + fileId(2) + ":" + seq(3) + "/" + totalChunks(3) + ":" + base64Data
       *   Data (seq > 1):
       *     sender(9) + ">" + receiver(9) + ":" + fileId(2) + ":" + seq(3) + ":" + base64Data
       **********************************************************************/
      function processRawPacket(packet) {
        console.log("Processing raw packet:", packet);
        if (typeof packet !== 'string') {
          console.log("Packet is not a string; ignoring.");
          return;
        }
        // --- ACK Packet Detection ---
        if (packet.slice(23,27) === "ACK:") {
          console.log("Received ACK packet:", packet);
          // Extract the fileId from the ACK packet (characters 20-22)
          const ackFileId = packet.slice(20,22);
          if (!sentFileStats || ackFileId !== sentFileStats.fileId) {
            console.log("Received ACK for a different file transfer (fileId mismatch). Ignoring ACK.");
            return;
          }
          const ackSeqStr = packet.slice(27,30);
          const ackSeq = parseInt(ackSeqStr, 10);
          console.log("ACK details - Seq:", ackSeq);
          if (ackSeq === currentPacketIndex + 1) {
            console.log("ACK matches current packet. Clearing ACK timer and moving to next packet.");
            clearTimeout(ackTimer);
            currentRetries = 0;
            currentPacketIndex++;
            sendCurrentPacket(
              document.getElementById('senderCallsign').value,
              document.getElementById('receiverCallsign').value
            );
          } else {
            console.log("ACK packet seq", ackSeq, "does not match expected", currentPacketIndex + 1);
          }
          return;
        }
        
        // --- Data/Metadata Packet Processing ---
        if (packet.indexOf('>') !== 9) {
          console.log("Packet format invalid: missing or misplaced '>'");
          return;
        }
        const sender = packet.slice(0,9).trim();
        const receiver = packet.slice(10,19).trim();
        console.log("Parsed sender:", sender, "Parsed receiver:", receiver);
        if (packet.charAt(19) !== ':') {
          console.log("Packet format invalid: missing colon at position 19.");
          return;
        }
        const fileId = packet.slice(20,22);
        if (packet.charAt(22) !== ':') {
          console.log("Packet format invalid: missing colon at position 22 after file ID.");
          return;
        }
        const seqStr = packet.slice(23,26);
        const seq = parseInt(seqStr, 10);
        let totalChunks = null;
        let base64Data = "";
        let payloadChunk;
        
        if (seq === 1) {
          if (packet.charAt(26) !== '/') {
            console.log("Header packet format invalid: expected '/' at position 26.");
            return;
          }
          const totalStr = packet.slice(27,30);
          totalChunks = parseInt(totalStr, 10);
          if (packet.charAt(30) !== ':') {
            console.log("Header packet format invalid: missing colon at position 30.");
            return;
          }
          base64Data = packet.slice(31);
        } else {
          if (packet.charAt(26) !== ':') {
              console.log("Data packet format invalid: expected colon at position 26.");
              return;
          }
          base64Data = packet.slice(27);
        }
        console.log("Packet details - Seq:", seq, "Total (if header):", totalChunks,
                    "Base64 Data (truncated):", base64Data.substring(0,20) + "...");
        try {
          payloadChunk = base64ToUint8Array(base64Data);
        } catch (e) {
          console.error("Error decoding Base64 data:", e);
          return;
        }
        const localCallsign = document.getElementById('senderCallsign').value.trim();
        console.log("Local callsign is:", localCallsign);
        if (receiver !== localCallsign) {
          console.log("Ignoring packet not intended for me (receiver:", receiver, ", local:", localCallsign, ")");
          return;
        }
        
        const transferKeyFinal = sender + "_" + fileId;
        if (!activeTransfers[transferKeyFinal] && seq !== 1) {
          console.log(`Received packet ${seq} from sender ${sender} (file ID: ${fileId}) before receiving the header. Ignoring packet.`);
          return;
        }
        
        // Send ACK packet (no CRC included).
        const ackPacket = buildAckPacket(localCallsign, sender, fileId, seq);
        console.log("Sending ACK for packet", seq, "with packet:", ackPacket);
        socket.emit('send_raw', { packet: ackPacket });
        console.log("ACK sent for packet", seq);
        
        if (activeTransfers[transferKeyFinal] && activeTransfers[transferKeyFinal].completed) {
          activeTransfers[transferKeyFinal].lastUpdate = Date.now();
          console.log("Transfer already completed for", transferKeyFinal, "; ACK sent, no further processing.");
          return;
        }
        
        if (!activeTransfers[transferKeyFinal] || seq === 1) {
          console.log("Starting new transfer from sender", sender, "with file ID", fileId);
          activeTransfers[transferKeyFinal] = { 
            totalChunks: seq === 1 ? totalChunks : null, 
            received: {}, 
            startTime: Date.now(), 
            duplicateCount: 0,
            lastUpdate: Date.now()
          };
          if (seq === 1) {
            const headerText = new TextDecoder().decode(payloadChunk);
            const parts = headerText.split("|");
            if (parts.length !== 5) {
              console.error("Invalid header payload received from sender", sender, "with file ID", fileId);
              return;
            }
            activeTransfers[transferKeyFinal].header = {
              fileName: parts[0],
              originalSize: parseInt(parts[1], 10),
              compressedSize: parseInt(parts[2], 10),
              md5: parts[3],
              fileId: parts[4]
            };
            activeTransfers[transferKeyFinal].totalChunks = totalChunks;
            console.log("Received header from sender", sender, "for file ID", fileId, activeTransfers[transferKeyFinal].header);
          }
        } else {
          if (activeTransfers[transferKeyFinal].received[seq]) {
            activeTransfers[transferKeyFinal].duplicateCount++;
            console.log("Duplicate packet", seq, "received from", transferKeyFinal, "Total duplicates:", activeTransfers[transferKeyFinal].duplicateCount);
          }
        }
        activeTransfers[transferKeyFinal].received[seq] = payloadChunk;
        if (!activeTransfers[transferKeyFinal].rawBytesReceived) {
          activeTransfers[transferKeyFinal].rawBytesReceived = 0;
        }
        activeTransfers[transferKeyFinal].rawBytesReceived += packet.length;
        activeTransfers[transferKeyFinal].lastUpdate = Date.now();
        const receivedCount = Object.keys(activeTransfers[transferKeyFinal].received).length;
        console.log("Stored packet", seq, "from", transferKeyFinal, "(", receivedCount, "/", activeTransfers[transferKeyFinal].totalChunks, ")");
        
        updateReceiverProgressUI();
        
        if (!activeTransfers[transferKeyFinal].completed &&
            activeTransfers[transferKeyFinal].totalChunks &&
            receivedCount === activeTransfers[transferKeyFinal].totalChunks) {
          console.log("All packets received for", transferKeyFinal, "- reassembling file...");
          if (!activeTransfers[transferKeyFinal].header) {
            console.error("Missing header information for", transferKeyFinal);
            return;
          }
          const dataChunks = [];
          for (let i = 2; i <= activeTransfers[transferKeyFinal].totalChunks; i++) {
            if (!activeTransfers[transferKeyFinal].received[i]) {
              console.error("Missing packet", i, "for", transferKeyFinal);
              return;
            }
            dataChunks.push(activeTransfers[transferKeyFinal].received[i]);
          }
          const totalLength = dataChunks.reduce((acc, cur) => acc + cur.length, 0);
          const fullCompressed = new Uint8Array(totalLength);
          let offset = 0;
          dataChunks.forEach(chunk => {
            fullCompressed.set(chunk, offset);
            offset += chunk.length;
          });
          console.log("Reassembled compressed file length:", fullCompressed.length);
          let decompressed;
          try {
            decompressed = pako.inflate(fullCompressed);
          } catch (err) {
            console.error("Error decompressing full file for", transferKeyFinal, ":", err);
            return;
          }
          console.log("Decompressed file length:", decompressed.length);
          const blob = new Blob([decompressed]);
          const elapsed = Date.now() - activeTransfers[transferKeyFinal].startTime;
          const dupCount = activeTransfers[transferKeyFinal].duplicateCount;
          const computedMd5 = CryptoJS.MD5(CryptoJS.lib.WordArray.create(decompressed)).toString();
          const checksumMatch = (computedMd5 === activeTransfers[transferKeyFinal].header.md5);
          const fileObj = {
            sender: sender,
            fileName: activeTransfers[transferKeyFinal].header.fileName,
            originalSize: activeTransfers[transferKeyFinal].header.originalSize,
            compressedSize: activeTransfers[transferKeyFinal].header.compressedSize,
            size: blob.size,
            elapsed: elapsed,
            duplicates: dupCount,
            totalPackets: activeTransfers[transferKeyFinal].totalChunks,
            timestamp: Date.now(),
            checksumMatch: checksumMatch,
            bytesReceived: activeTransfers[transferKeyFinal].rawBytesReceived || 0
          };
          const reader = new FileReader();
          reader.onload = function(e) {
            fileObj.dataUrl = e.target.result;
            persistentReceivedFiles.push(fileObj);
            saveReceivedFilesToLocalStorage(persistentReceivedFiles);
            updateReceivedFilesUI();
          };
          reader.onerror = function(e) {
            console.error("Error converting Blob to Data URL:", e);
          };
          reader.readAsDataURL(blob);
          console.log("File transfer complete for", transferKeyFinal);
          activeTransfers[transferKeyFinal].completed = true;
          activeTransfers[transferKeyFinal].completionTime = Date.now();
          setTimeout(() => {
            console.log("Clearing completed transfer for", transferKeyFinal);
            delete activeTransfers[transferKeyFinal];
            updateReceiverProgressUI();
          }, 30000);
          updateReceiverProgressUI();
        }
      }
      
      /**********************************************************************
       * Socket Event Handlers
       **********************************************************************/
      const socket = io('/');
      socket.onAny((event, ...args) => {
        console.log('Socket event:', event, args);
      });
      socket.on('connect', () => {
        console.log("Socket connected, id:", socket.id);
      });
      socket.on('connect_error', (err) => {
        console.error("Socket connection error:", err);
      });
      socket.on('aprs_packet', (data) => {
        console.log("Received aprs_packet event:", data);
        const packet = (typeof data === 'object' && data.raw) ? data.raw : data;
        processRawPacket(packet);
      });
      socket.on('raw_packet', (packet) => {
        console.log("Received raw_packet event:", packet);
        processRawPacket(packet);
      });
      
      /**********************************************************************
       * Sender-Side Code (for Testing)
       **********************************************************************/
      document.getElementById('sendFileBtn').addEventListener('click', () => {
        const sender = document.getElementById('senderCallsign').value.trim();
        const receiver = document.getElementById('receiverCallsign').value.trim();
        const fileInput = document.getElementById('fileInput');
        if (!sender || !receiver || fileInput.files.length === 0) {
          alert("Please enter your callsign, receiver callsign, and select a file.");
          return;
        }
        const file = fileInput.files[0];
        // Removed reading of the CRC checkbox value.
        const fileId = generateFileId();
        const reader = new FileReader();
        reader.onload = function(e) {
          const arrayBuffer = e.target.result;
          const fileData = new Uint8Array(arrayBuffer);
          let compressed;
          try {
            compressed = pako.deflate(fileData, { level: 9 });
          } catch (err) {
            updateStatus("Compression error: " + err);
            return;
          }
          const md5 = CryptoJS.MD5(CryptoJS.lib.WordArray.create(fileData)).toString();
          const fileDataChunksCount = Math.ceil(compressed.length / 165);
          const totalPackets = fileDataChunksCount + 1;
          currentFilePackets = [];
          // Header metadata: fileName|originalSize|compressedSize|md5|fileId
          const headerStr = file.name + "|" + fileData.length + "|" + compressed.length + "|" + md5 + "|" + fileId;
          const headerPayload = new TextEncoder().encode(headerStr);
          const headerPacket = buildPacket(sender, receiver, 1, totalPackets, headerPayload, fileId);
          currentFilePackets.push(headerPacket);
          for (let i = 0; i < fileDataChunksCount; i++) {
            const start = i * 165;
            const end = Math.min(start + 165, compressed.length);
            const chunk = compressed.slice(start, end);
            const packet = buildPacket(sender, receiver, i + 2, totalPackets, chunk, fileId);
            currentFilePackets.push(packet);
          }
          currentPacketIndex = 0;
          currentRetries = 0;
          totalRetries = 0;
          fileTransferInProgress = true;
          // Save fileId into sentFileStats so that updateSenderProgressUI() can display it.
          sentFileStats = {
            fileName: file.name,
            receiver: receiver,
            originalSize: fileData.length,
            compressedSize: compressed.length,
            startTime: Date.now(),
            totalRetries: 0,
            bytesSent: 0,
            totalPackets: currentFilePackets.length,
            fileId: fileId
          };
          updateStatus(`File compressed from ${fileData.length} bytes to ${compressed.length} bytes.
                       Transfer will begin with a header packet containing file metadata and MD5 checksum.
                       File ID: ${fileId}`);
          updateSenderProgressUI();
          sendCurrentPacket(sender, receiver);
        };
        reader.onerror = function(e) {
          updateStatus("Error reading file: " + e);
        };
        reader.readAsArrayBuffer(file);
      });
      
      // (Optional) Fetch settings from /api/settings to pre-populate your callsign.
      fetch('/api/settings')
        .then(response => response.json())
        .then(settings => {
          document.getElementById('senderCallsign').value = settings.my_callsign;
        })
        .catch(error => {
          console.error("Error fetching settings:", error);
        });
      
    });
  </script>
</body>
</html>
