<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>File Transfer</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Socket.IO -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js"></script>
  <!-- CryptoJS for MD5 checksum -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <!-- Pako for compression/decompression -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <style>
    body { padding: 20px; }
    #status { margin-top: 1rem; font-weight: bold; }
    .progress { height: 20px; margin-bottom: 10px; }
    /* Make the retries dropdown inline with the compress checkbox */
    .inline-control { display: inline-block; vertical-align: middle; margin-left: 20px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>File Transfer</h1>
    
    <!-- Settings: These values would normally be fetched from /api/settings -->
    <div class="mb-3">
      <label for="senderCallsign" class="form-label">Your Callsign</label>
      <input type="text" id="senderCallsign" class="form-control" placeholder="Fetching your callsign...">
    </div>
    <div class="mb-3">
      <label for="receiverCallsign" class="form-label">Receiver Callsign (for sending)</label>
      <input type="text" id="receiverCallsign" class="form-control" placeholder="Enter receiver callsign">
    </div>
    <div class="mb-3">
      <label for="fileInput" class="form-label">File to Send</label>
      <input type="file" id="fileInput" class="form-control">
    </div>
    <!-- New Compress Checkbox and Retries Dropdown -->
    <div class="mb-3">
      <div class="form-check" style="display: inline-block;">
        <input type="checkbox" class="form-check-input" id="compressCheckbox" checked>
        <label class="form-check-label" for="compressCheckbox">Compress</label>
      </div>
      <div class="inline-control">
        <label for="retriesDropdown" class="form-label" style="margin-bottom: 0;">Retries</label>
        <select id="retriesDropdown" class="form-select" style="width: auto; display: inline-block; margin-left: 10px;">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3" selected>3</option>
          <option value="4">4</option>
          <option value="5">5</option>
        </select>
      </div>
    </div>
    
    <button id="sendFileBtn" class="btn btn-primary">Send File</button>
    <!-- New Cancel Button (initially hidden) -->
    <button id="cancelBtn" class="btn btn-secondary" style="display: none;">Cancel</button>
    <div id="status"></div>
    
    <hr>
    <h2>Sender Progress</h2>
    <div id="senderProgress">
      <p>No file being sent.</p>
    </div>
    
    <hr>
    <h2>Sent Files</h2>
    <div id="sentFiles">
      <p>No files sent yet.</p>
    </div>
    
    <hr>
    <h2>Receiver Progress</h2>
    <div id="receiverProgress">
      <p>No active transfers.</p>
    </div>
    
    <hr>
    <h2>Received Files</h2>
    <div id="receivedFiles">
      <p>No files received yet.</p>
    </div>
  </div>
  
  <!-- Bootstrap Bundle -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  
  <script>
    document.addEventListener("DOMContentLoaded", function() {

      /**********************************************************************
       * Utility Functions
       **********************************************************************/
      function padCallsign(cs) {
        return cs.toUpperCase().padEnd(9, ' ');
      }
      
      // Generate a random 2-character file ID using case-sensitive alphanumerics.
      function generateFileId() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        return chars.charAt(Math.floor(Math.random() * chars.length)) +
               chars.charAt(Math.floor(Math.random() * chars.length));
      }
      
      /**********************************************************************
       * Persistence Functions for Sent & Received Files
       **********************************************************************/
      function saveReceivedFilesToLocalStorage(filesArray) {
        try {
          localStorage.setItem("receivedFiles", JSON.stringify(filesArray));
        } catch (e) {
          console.error("Error saving received files to localStorage:", e);
        }
      }
      
      function loadReceivedFilesFromLocalStorage() {
        const data = localStorage.getItem("receivedFiles");
        if (data) {
          try {
            return JSON.parse(data);
          } catch (e) {
            console.error("Error parsing received files from localStorage:", e);
          }
        }
        return [];
      }
      
      function saveSentFilesToLocalStorage(filesArray) {
        try {
          localStorage.setItem("sentFiles", JSON.stringify(filesArray));
        } catch (e) {
          console.error("Error saving sent files to localStorage:", e);
        }
      }
      
      function loadSentFilesFromLocalStorage() {
        const data = localStorage.getItem("sentFiles");
        if (data) {
          try {
            return JSON.parse(data);
          } catch (e) {
            console.error("Error parsing sent files from localStorage:", e);
          }
        }
        return [];
      }
      
      /**********************************************************************
       * UI Update Functions
       **********************************************************************/
      function updateReceivedFilesUI() {
        const container = document.getElementById('receivedFiles');
        if (persistentReceivedFiles.length === 0) {
          container.innerHTML = "<p>No files received yet.</p>";
          return;
        }
        let html = '<table class="table table-striped"><thead><tr><th>Date/Time</th><th>Sender</th><th>File Name</th><th>Original Size</th><th>Compressed Size</th><th>Size (decompressed)</th><th>Elapsed Time (s)</th><th>Speed (Bytes/s)</th><th>Duplicates</th><th>Checksum</th><th>Download</th><th>Delete</th></tr></thead><tbody>';
        persistentReceivedFiles.forEach((file, index) => {
          const checksumIcon = file.checksumMatch 
            ? '<span style="color:green;">&#10004;</span>' 
            : '<span style="color:red;">&#10008;</span>';
          const elapsedSec = file.elapsed / 1000;
          const speed = elapsedSec > 0 ? Math.floor((file.bytesReceived || file.size) / elapsedSec) : 0;
          const dupPercent = file.totalPackets ? Math.round((file.duplicates / file.totalPackets) * 100) : "0";
          html += `<tr>
                     <td>${new Date(file.timestamp).toLocaleString()}</td>
                     <td>${file.sender}</td>
                     <td>${file.fileName}</td>
                     <td>${file.originalSize} bytes</td>
                     <td>${file.compressedSize} bytes</td>
                     <td>${file.size} bytes</td>
                     <td>${(elapsedSec).toFixed(2)}</td>
                     <td>${speed}</td>
                     <td>${file.duplicates} (${dupPercent}%)</td>
                     <td>${checksumIcon}</td>
                     <td><button class="btn btn-success btn-sm" onclick="downloadReceivedFile(${index})">Download</button></td>
                     <td><button class="btn btn-danger btn-sm" onclick="deleteReceivedFile(${index})">Delete</button></td>
                   </tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      
      function updateSentFilesUI() {
        const container = document.getElementById('sentFiles');
        if (persistentSentFiles.length === 0) {
          container.innerHTML = "<p>No files sent yet.</p>";
          return;
        }
        let html = '<table class="table table-striped"><thead><tr><th>Date/Time</th><th>Receiver</th><th>File Name</th><th>Original Size</th><th>Compressed Size</th><th>Retries</th><th>Total Time (s)</th><th>Speed (Bytes/s)</th><th>Clear</th></tr></thead><tbody>';
        persistentSentFiles.forEach((stat, index) => {
          const totalTime = parseFloat(stat.totalTime);
          const speed = totalTime > 0 ? Math.floor(stat.bytesSent / totalTime) : 0;
          const retryPercent = stat.totalPackets ? Math.round(stat.totalRetries / stat.totalPackets * 100) : "0";
          html += `<tr>
                     <td>${new Date(stat.timestamp).toLocaleString()}</td>
                     <td>${stat.receiver || ""}</td>
                     <td>${stat.fileName}</td>
                     <td>${stat.originalSize} bytes</td>
                     <td>${stat.compressedSize} bytes</td>
                     <td>${stat.totalRetries} (${retryPercent}%)</td>
                     <td>${stat.totalTime}</td>
                     <td>${speed}</td>
                     <td><button class="btn btn-warning btn-sm" onclick="clearSentFile(${index})">Clear</button></td>
                   </tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      
      window.downloadReceivedFile = function(index) {
        const file = persistentReceivedFiles[index];
        if (!file) return;
        const a = document.createElement('a');
        a.href = file.dataUrl;
        a.download = file.fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      };
      
      window.deleteReceivedFile = function(index) {
        persistentReceivedFiles.splice(index, 1);
        saveReceivedFilesToLocalStorage(persistentReceivedFiles);
        updateReceivedFilesUI();
      };
      
      window.clearSentFile = function(index) {
        persistentSentFiles.splice(index, 1);
        saveSentFilesToLocalStorage(persistentSentFiles);
        updateSentFilesUI();
      };
      
      /**********************************************************************
       * Global Persistent Variables
       **********************************************************************/
      let persistentReceivedFiles = loadReceivedFilesFromLocalStorage();
      let persistentSentFiles = loadSentFilesFromLocalStorage();
      
      updateReceivedFilesUI();
      updateSentFilesUI();
      
      /**********************************************************************
       * Packet Building Functions for Raw Binary KISS Frames
       *
       * Packet formats (binary):
       * Header packet (seq === 1):
       *   ASCII header: sender(9) + ">" + receiver(9) + ":" + fileId(2) + ":" + seq(3) + "/" + totalChunks(3) + ":"
       *   followed by binary payload (metadata, e.g., "fileName|originalSize|compressedSize|md5|fileId|compressionFlag")
       *
       * Data packet (seq > 1):
       *   ASCII header: sender(9) + ">" + receiver(9) + ":" + fileId(2) + ":" + seq(3) + ":"
       *   followed by binary payload (file chunk)
       *
       * ACK packet:
       *   ASCII header: sender(9) + ">" + receiver(9) + ":" + fileId(2) + ":" + "ACK:" + seq(3)
       **********************************************************************/
      
      function buildPacket(sender, receiver, seq, totalChunks, payloadChunk, fileId) {
        const s = padCallsign(sender);
        const r = padCallsign(receiver);
        const seqStr = seq.toString().padStart(3, '0');
        let headerStr = "";
        if (seq === 1) {
          const totalStr = totalChunks.toString().padStart(3, '0');
          headerStr = s + '>' + r + ':' + fileId + ':' + seqStr + '/' + totalStr + ':';
        } else {
          headerStr = s + '>' + r + ':' + fileId + ':' + seqStr + ':';
        }
        const encoder = new TextEncoder();
        const headerBytes = encoder.encode(headerStr);
        const packetBytes = new Uint8Array(headerBytes.length + payloadChunk.length);
        packetBytes.set(headerBytes, 0);
        packetBytes.set(payloadChunk, headerBytes.length);
        return packetBytes;
      }
      
      function buildAckPacket(ackSender, ackReceiver, fileId, seq) {
        const s = padCallsign(ackSender);
        const r = padCallsign(ackReceiver);
        const seqStr = seq.toString().padStart(3, '0');
        const ackStr = s + '>' + r + ':' + fileId + ':' + "ACK:" + seqStr;
        const encoder = new TextEncoder();
        return encoder.encode(ackStr);
      }
      
      // Escape any occurrence of FEND (0xC0) or FESC (0xDB) in the data.
      function escapeKissData(data) {
        let output = [];
        for (let i = 0; i < data.length; i++) {
          const byte = data[i];
          if (byte === 0xC0) {
            // FEND becomes FESC, TFEND (0xDB,0xDC)
            output.push(0xDB, 0xDC);
          } else if (byte === 0xDB) {
            // FESC becomes FESC, TFESC (0xDB,0xDD)
            output.push(0xDB, 0xDD);
          } else {
            output.push(byte);
          }
        }
        return new Uint8Array(output);
      }
      
      // Unescape KISS data: replace FESC,TFEND with FEND and FESC,TFESC with FESC.
      function unescapeKissData(data) {
        let output = [];
        for (let i = 0; i < data.length; i++) {
          if (data[i] === 0xDB && i + 1 < data.length) {
            if (data[i+1] === 0xDC) {
              output.push(0xC0);
              i++;
              continue;
            } else if (data[i+1] === 0xDD) {
              output.push(0xDB);
              i++;
              continue;
            }
          }
          output.push(data[i]);
        }
        return new Uint8Array(output);
      }
      
      // Wrap an APRS packet (binary) in KISS framing with proper escaping.
      function buildKissFrame(aprsPacket) {
        const escapedPacket = escapeKissData(aprsPacket);
        const KISS_FLAG = 0xC0;
        const KISS_CMD_DATA = 0x00;
        const frame = new Uint8Array(1 + 1 + escapedPacket.length + 1);
        frame[0] = KISS_FLAG;
        frame[1] = KISS_CMD_DATA;
        frame.set(escapedPacket, 2);
        frame[frame.length - 1] = KISS_FLAG;
        return frame;
      }
      
      /**********************************************************************
       * Sender-Side Variables and Functions
       **********************************************************************/
      // We'll set the maximum number of retries based on the user's selection.
      let maxRetries = 3;  // default value (will be overwritten when "Send File" is clicked)
      
      let currentFilePackets = [];
      let currentPacketIndex = 0;
      let currentRetries = 0;
      let totalRetries = 0;
      let fileTransferInProgress = false;
      let ackTimer = null;
      let sentFileStats = null;
      
      function updateStatus(msg) {
        document.getElementById('status').innerText = msg;
        console.log(msg);
      }
      window.updateStatus = updateStatus;
      
      function updateSenderProgressUI() {
        const container = document.getElementById('senderProgress');
        const cancelBtn = document.getElementById('cancelBtn');
        if (!fileTransferInProgress || currentFilePackets.length === 0) {
          container.innerHTML = "<p>No file being sent.</p>";
          cancelBtn.style.display = "none";
          return;
        }
        cancelBtn.style.display = "inline-block";
        const now = Date.now();
        const elapsed = (now - sentFileStats.startTime) / 1000;
        const progressPercent = Math.floor((currentPacketIndex / currentFilePackets.length) * 100);
        let eta = "N/A";
        if (progressPercent > 0) {
          const estimatedTotal = elapsed / (progressPercent / 100);
          const remaining = estimatedTotal - elapsed;
          eta = remaining.toFixed(2) + " s";
        }
        const transferRate = elapsed > 0 ? sentFileStats.bytesSent / elapsed : 0;
        const retryPercent = currentFilePackets.length ? Math.round(totalRetries / currentFilePackets.length * 100) : 0;
        const html = `
          <h5>To ${sentFileStats.receiver} – ${sentFileStats.fileName} (ID: ${sentFileStats.fileId}) (${currentPacketIndex + 1}/${currentFilePackets.length} packets sent)</h5>
          <p>Original Size: ${sentFileStats.originalSize} bytes; Compressed Size: ${sentFileStats.compressedSize} bytes</p>
          <div class="progress">
            <div class="progress-bar" role="progressbar" style="width: ${progressPercent}%;" aria-valuenow="${progressPercent}" aria-valuemin="0" aria-valuemax="100">${progressPercent}%</div>
          </div>
          <p>Elapsed time: ${elapsed.toFixed(2)} s; ETA: ${eta} (${transferRate.toFixed(0)} bytes/sec); Retries: ${totalRetries} (${retryPercent}%)</p>
        `;
        container.innerHTML = html;
      }
      
      document.getElementById('cancelBtn').addEventListener('click', function() {
        if (fileTransferInProgress) {
          fileTransferInProgress = false;
          clearTimeout(ackTimer);
          updateStatus("File transfer canceled.");
          updateSenderProgressUI();
        }
      });
      
      function sendCurrentPacket(sender, receiver) {
        if (!fileTransferInProgress) return;
        if (currentPacketIndex >= currentFilePackets.length) {
          updateStatus("File transfer complete.");
          if (sentFileStats) {
            sentFileStats.endTime = Date.now();
            sentFileStats.totalTime = ((sentFileStats.endTime - sentFileStats.startTime) / 1000).toFixed(2);
            sentFileStats.totalRetries = totalRetries;
            sentFileStats.timestamp = sentFileStats.startTime;
            persistentSentFiles.push(sentFileStats);
            saveSentFilesToLocalStorage(persistentSentFiles);
            updateSentFilesUI();
            sentFileStats = null;
            totalRetries = 0;
          }
          fileTransferInProgress = false;
          updateSenderProgressUI();
          return;
        }
        updateSenderProgressUI();
        const packet = currentFilePackets[currentPacketIndex];
        if (!sentFileStats.bytesSent) {
          sentFileStats.bytesSent = 0;
        }
        sentFileStats.bytesSent += packet.length;
        updateStatus(`Sending packet ${currentPacketIndex + 1} of ${currentFilePackets.length} (Retry ${currentRetries})...`);
        const kissFrame = buildKissFrame(packet);
        socket.emit('raw_kiss_frame', kissFrame);
        ackTimer = setTimeout(() => {
          currentRetries++;
          totalRetries++;
          if (currentRetries <= maxRetries) {
            updateStatus(`No ACK for packet ${currentPacketIndex + 1}. Retrying (${currentRetries}/${maxRetries})...`);
            sendCurrentPacket(sender, receiver);
          } else {
            updateStatus(`Packet ${currentPacketIndex + 1} failed after ${maxRetries} retries.`);
            fileTransferInProgress = false;
            updateSenderProgressUI();
          }
        }, 10000);
      }
      
      /**********************************************************************
       * Receiver-Side Variables and Functions
       **********************************************************************/
      const activeTransfers = {};
      
      function updateReceiverProgressUI() {
        const container = document.getElementById('receiverProgress');
        const keys = Object.keys(activeTransfers).filter(key => !activeTransfers[key].completed);
        if (keys.length === 0) {
          container.innerHTML = "<p>No active transfers.</p>";
          return;
        }
        container.innerHTML = "";
        keys.forEach(key => {
          const transfer = activeTransfers[key];
          const [sender, fileId] = key.split('_');
          const receivedCount = Object.keys(transfer.received).length;
          const total = transfer.totalChunks;
          const progressPercent = total ? Math.floor((receivedCount / total) * 100) : 0;
          let headerInfo = "";
          if (transfer.header) {
            headerInfo = ` - ${transfer.header.fileName} (ID: ${fileId})`;
          } else {
            headerInfo = ` (ID: ${fileId})`;
          }
          const elapsed = transfer.startTime ? ((Date.now() - transfer.startTime) / 1000) : 0;
          let eta = "N/A";
          if (progressPercent > 0) {
            const estimatedTotal = elapsed / (progressPercent / 100);
            const remaining = estimatedTotal - elapsed;
            eta = remaining.toFixed(2) + " s";
          }
          let bytesPerSec = "0";
          if (elapsed > 0 && transfer.rawBytesReceived) {
            bytesPerSec = (transfer.rawBytesReceived / elapsed).toFixed(0) + "";
          }
          const dupCount = transfer.duplicateCount || 0;
          const dupPercent = total ? Math.round((dupCount / total) * 100) : "0";
          let progressHTML = `<h5>From ${sender}${headerInfo} (${receivedCount}/${total || "?"} packets received)</h5>`;
          if (transfer.header) {
            progressHTML += `<p>Original Size: ${transfer.header.originalSize} bytes; Compressed Size: ${transfer.header.compressedSize} bytes</p>`;
          }
          progressHTML += `
            <div class="progress">
              <div class="progress-bar" role="progressbar" style="width: ${progressPercent}%;" aria-valuenow="${progressPercent}" aria-valuemin="0" aria-valuemax="100">${progressPercent}%</div>
            </div>
            <p>Elapsed time: ${elapsed.toFixed(2)} s; ETA: ${eta} (${bytesPerSec} bytes/sec); Duplicate receptions: ${dupCount} (${dupPercent}%)</p>`;
          let elem = document.getElementById('progress_' + key);
          if (!elem) {
            elem = document.createElement('div');
            elem.id = 'progress_' + key;
            container.appendChild(elem);
          }
          elem.innerHTML = progressHTML;
        });
      }
      
      function checkInactiveTransfers() {
        const now = Date.now();
        for (const key in activeTransfers) {
          if (activeTransfers.hasOwnProperty(key)) {
            const transfer = activeTransfers[key];
            if (now - transfer.lastUpdate > 30000) {
              console.log(`Transfer ${key} timed out due to 30 seconds of inactivity.`);
              delete activeTransfers[key];
              updateReceiverProgressUI();
            }
          }
        }
      }
      setInterval(checkInactiveTransfers, 1000);
      
      /**********************************************************************
       * Common Packet Processing Function for Raw Binary KISS Frames
       **********************************************************************/
      function processRawPacket(packet) {
        console.log("Processing raw packet:", packet);
        let packetBytes;
        if (typeof packet === 'string') {
          packetBytes = new TextEncoder().encode(packet);
        } else if (packet instanceof ArrayBuffer) {
          packetBytes = new Uint8Array(packet);
        } else if (packet instanceof Uint8Array) {
          packetBytes = packet;
        } else {
          console.log("Unrecognized packet type; ignoring.");
          return;
        }
        // Verify KISS framing (must start and end with 0xC0)
        if (packetBytes[0] !== 0xC0 || packetBytes[packetBytes.length - 1] !== 0xC0) {
          console.error("Invalid KISS frame: missing framing bytes.");
          return;
        }
        // Remove KISS flag and command byte, and the trailing flag.
        const ax25Frame = packetBytes.slice(2, packetBytes.length - 1);
        // Determine header length based on packet type.
        let headerLength;
        const preliminaryHeader = new TextDecoder().decode(ax25Frame.slice(0, 28));
        if (preliminaryHeader.slice(23, 27) === "ACK:") {
          headerLength = 30;
        } else if (ax25Frame[26] === 0x2F) {
          headerLength = 31;
        } else {
          headerLength = 27;
        }
        const headerText = new TextDecoder().decode(ax25Frame.slice(0, headerLength));
        // ACK packet detection: check if characters 23–26 equal "ACK:"
        if (headerText.slice(23,27) === "ACK:") {
          console.log("Received ACK packet:", headerText);
          const ackFileId = headerText.slice(20,22);
          const localCallsign = document.getElementById('senderCallsign').value.trim();
          if (!sentFileStats || ackFileId !== sentFileStats.fileId) {
            console.log("Received ACK for a different file transfer (fileId mismatch). Ignoring ACK.");
            return;
          }
          const ackSeqStr = headerText.slice(27,30);
          const ackSeq = parseInt(ackSeqStr, 10);
          console.log("ACK details - Seq:", ackSeq);
          if (ackSeq === currentPacketIndex + 1) {
            console.log("ACK matches current packet. Clearing ACK timer and moving to next packet.");
            clearTimeout(ackTimer);
            currentRetries = 0;
            currentPacketIndex++;
            sendCurrentPacket(
              document.getElementById('senderCallsign').value,
              document.getElementById('receiverCallsign').value
            );
          } else {
            console.log("ACK packet seq", ackSeq, "does not match expected", currentPacketIndex + 1);
          }
          return;
        }
        
        // Data/Metadata Packet Processing
        if (headerText.indexOf('>') !== 9) {
          console.log("Packet format invalid: missing or misplaced '>'");
          return;
        }
        const sender = headerText.slice(0,9).trim();
        const receiver = headerText.slice(10,19).trim();
        if (headerText.charAt(19) !== ':') {
          console.log("Packet format invalid: missing colon at position 19.");
          return;
        }
        const fileId = headerText.slice(20,22);
        if (headerText.charAt(22) !== ':') {
          console.log("Packet format invalid: missing colon at position 22 after file ID.");
          return;
        }
        const seqStr = headerText.slice(23,26);
        const seq = parseInt(seqStr, 10);
        let totalChunks = null;
        if (seq === 1) {
          if (headerText.charAt(26) !== '/') {
            console.log("Header packet format invalid: expected '/' at position 26.");
            return;
          }
          const totalStr = headerText.slice(27,30);
          totalChunks = parseInt(totalStr, 10);
          if (headerText.charAt(30) !== ':') {
            console.log("Header packet format invalid: missing colon at position 30.");
            return;
          }
        } else {
          if (headerText.charAt(26) !== ':') {
              console.log("Data packet format invalid: expected colon at position 26.");
              return;
          }
        }
        console.log("Packet details - Seq:", seq, "Total (if header):", totalChunks);
        // IMPORTANT: Unescape the payload portion.
        const payloadChunkEscaped = ax25Frame.slice(headerLength);
        const payloadChunk = unescapeKissData(payloadChunkEscaped);
        
        const localCallsign = document.getElementById('senderCallsign').value.trim();
        if (receiver !== localCallsign) {
          console.log("Ignoring packet not intended for me (receiver:", receiver, ", local:", localCallsign, ")");
          return;
        }
        
        const transferKeyFinal = sender + "_" + fileId;
        if (!activeTransfers[transferKeyFinal] && seq !== 1) {
          console.log(`Received packet ${seq} from sender ${sender} (file ID: ${fileId}) before receiving the header. Ignoring packet.`);
          return;
        }
        
        // Send ACK packet.
        const ackPacketBytes = buildAckPacket(localCallsign, sender, fileId, seq);
        const ackKissFrame = buildKissFrame(ackPacketBytes);
        console.log("Sending ACK for packet", seq);
        socket.emit('raw_kiss_frame', ackKissFrame);
        
        if (activeTransfers[transferKeyFinal] && activeTransfers[transferKeyFinal].completed) {
          activeTransfers[transferKeyFinal].lastUpdate = Date.now();
          console.log("Transfer already completed for", transferKeyFinal, "; ACK sent, no further processing.");
          return;
        }
        
        // Only store the packet if not already present.
        if (!activeTransfers[transferKeyFinal] || seq === 1) {
          console.log("Starting new transfer from sender", sender, "with file ID", fileId);
          activeTransfers[transferKeyFinal] = { 
            totalChunks: seq === 1 ? totalChunks : null, 
            received: {}, 
            startTime: Date.now(), 
            duplicateCount: 0,
            lastUpdate: Date.now()
          };
          if (seq === 1) {
            const headerPayloadText = new TextDecoder().decode(payloadChunk);
            const parts = headerPayloadText.split("|");
            if (parts.length < 6) {
              // If the compression flag is missing, assume compression is enabled.
              parts.push("1");
            }
            activeTransfers[transferKeyFinal].header = {
              fileName: parts[0],
              originalSize: parseInt(parts[1], 10),
              compressedSize: parseInt(parts[2], 10),
              md5: parts[3],
              fileId: parts[4],
              compression: (parts[5] === "1")
            };
            activeTransfers[transferKeyFinal].totalChunks = totalChunks;
            console.log("Received header from sender", sender, "for file ID", fileId, activeTransfers[transferKeyFinal].header);
          }
          activeTransfers[transferKeyFinal].received[seq] = payloadChunk;
        } else {
          if (activeTransfers[transferKeyFinal].received[seq]) {
            activeTransfers[transferKeyFinal].duplicateCount++;
            console.log("Duplicate packet", seq, "received from", transferKeyFinal, "Total duplicates:", activeTransfers[transferKeyFinal].duplicateCount);
            // Do not overwrite the existing packet.
          } else {
            activeTransfers[transferKeyFinal].received[seq] = payloadChunk;
          }
        }
        if (!activeTransfers[transferKeyFinal].rawBytesReceived) {
          activeTransfers[transferKeyFinal].rawBytesReceived = 0;
        }
        activeTransfers[transferKeyFinal].rawBytesReceived += ax25Frame.length;
        activeTransfers[transferKeyFinal].lastUpdate = Date.now();
        const receivedCount = Object.keys(activeTransfers[transferKeyFinal].received).length;
        console.log("Stored packet", seq, "from", transferKeyFinal, "(", receivedCount, "/", activeTransfers[transferKeyFinal].totalChunks, ")");
        
        updateReceiverProgressUI();
        
        if (!activeTransfers[transferKeyFinal].completed &&
            activeTransfers[transferKeyFinal].totalChunks &&
            receivedCount === activeTransfers[transferKeyFinal].totalChunks) {
          console.log("All packets received for", transferKeyFinal, "- reassembling file...");
          if (!activeTransfers[transferKeyFinal].header) {
            console.error("Missing header information for", transferKeyFinal);
            return;
          }
          const dataChunks = [];
          for (let i = 2; i <= activeTransfers[transferKeyFinal].totalChunks; i++) {
            if (!activeTransfers[transferKeyFinal].received[i]) {
              console.error("Missing packet", i, "for", transferKeyFinal);
              return;
            }
            dataChunks.push(activeTransfers[transferKeyFinal].received[i]);
          }
          let totalLength = 0;
          dataChunks.forEach(chunk => { totalLength += chunk.length; });
          let fullCompressed = new Uint8Array(totalLength);
          let offset = 0;
          dataChunks.forEach(chunk => {
            fullCompressed.set(chunk, offset);
            offset += chunk.length;
          });
          console.log("Reassembled compressed file length:", fullCompressed.length);
          if (fullCompressed.length !== activeTransfers[transferKeyFinal].header.compressedSize) {
            console.warn("Reassembled length (" + fullCompressed.length +
              ") does not match expected compressed size (" + activeTransfers[transferKeyFinal].header.compressedSize + ").");
          }
          let decompressed;
          if (activeTransfers[transferKeyFinal].header.compression) {
            try {
              decompressed = pako.inflate(fullCompressed);
            } catch (err) {
              console.error("Error decompressing full file for", transferKeyFinal, ":", err);
              return;
            }
          } else {
            decompressed = fullCompressed;
          }
          console.log("Decompressed file length:", decompressed.length);
          const blob = new Blob([decompressed]);
          const elapsed = Date.now() - activeTransfers[transferKeyFinal].startTime;
          const dupCount = activeTransfers[transferKeyFinal].duplicateCount;
          const computedMd5 = CryptoJS.MD5(CryptoJS.lib.WordArray.create(decompressed)).toString();
          const checksumMatch = (computedMd5 === activeTransfers[transferKeyFinal].header.md5);
          const fileObj = {
            sender: sender,
            fileName: activeTransfers[transferKeyFinal].header.fileName,
            originalSize: activeTransfers[transferKeyFinal].header.originalSize,
            compressedSize: activeTransfers[transferKeyFinal].header.compressedSize,
            size: blob.size,
            elapsed: elapsed,
            duplicates: dupCount,
            totalPackets: activeTransfers[transferKeyFinal].totalChunks,
            timestamp: Date.now(),
            checksumMatch: checksumMatch,
            bytesReceived: activeTransfers[transferKeyFinal].rawBytesReceived || 0
          };
          const reader = new FileReader();
          reader.onload = function(e) {
            fileObj.dataUrl = e.target.result;
            persistentReceivedFiles.push(fileObj);
            saveReceivedFilesToLocalStorage(persistentReceivedFiles);
            updateReceivedFilesUI();
          };
          reader.onerror = function(e) {
            console.error("Error converting Blob to Data URL:", e);
          };
          reader.readAsDataURL(blob);
          console.log("File transfer complete for", transferKeyFinal);
          activeTransfers[transferKeyFinal].completed = true;
          activeTransfers[transferKeyFinal].completionTime = Date.now();
          // Increase the time before clearing completed transfers (from 30 sec to 60 sec)
          setTimeout(() => {
            console.log("Clearing completed transfer for", transferKeyFinal);
            delete activeTransfers[transferKeyFinal];
            updateReceiverProgressUI();
          }, 60000);
          updateReceiverProgressUI();
        }
      }
      
      /**********************************************************************
       * Socket Event Handlers
       **********************************************************************/
      const socket = io('/');
      socket.onAny((event, ...args) => {
        if (event === "raw_kiss_frame") {
          console.log('Socket event:', event, args);
        }
      });
      socket.on('connect', () => {
        console.log("Socket connected, id:", socket.id);
      });
      socket.on('connect_error', (err) => {
        console.error("Socket connection error:", err);
      });
      // Only listen for raw_kiss_frame events
      socket.on('raw_kiss_frame', (packet) => {
        console.log("Received raw_kiss_frame event:", packet);
        processRawPacket(packet);
      });
      
      /**********************************************************************
       * Sender-Side Code (for Testing)
       **********************************************************************/
      document.getElementById('sendFileBtn').addEventListener('click', () => {
        const sender = document.getElementById('senderCallsign').value.trim();
        const receiver = document.getElementById('receiverCallsign').value.trim();
        const fileInput = document.getElementById('fileInput');
        if (!sender || !receiver || fileInput.files.length === 0) {
          alert("Please enter your callsign, receiver callsign, and select a file.");
          return;
        }
        // Read the state of the "Compress" checkbox (default on)
        const compress = document.getElementById('compressCheckbox').checked;
        // Read the selected number of retries from the dropdown.
        maxRetries = parseInt(document.getElementById('retriesDropdown').value, 10);
        const file = fileInput.files[0];
        const fileId = generateFileId();
        const reader = new FileReader();
        reader.onload = function(e) {
          const arrayBuffer = e.target.result;
          const fileData = new Uint8Array(arrayBuffer);
          let finalData;
          if (compress) {
            try {
              finalData = pako.deflate(fileData, { level: 9 });
            } catch (err) {
              updateStatus("Compression error: " + err);
              return;
            }
          } else {
            finalData = fileData;
          }
          const md5 = CryptoJS.MD5(CryptoJS.lib.WordArray.create(fileData)).toString();
          const fileDataChunksCount = Math.ceil(finalData.length / 165);
          const totalPackets = fileDataChunksCount + 1;
          currentFilePackets = [];
          // Header metadata: fileName|originalSize|finalDataLength|md5|fileId|compressionFlag (1 for compress, 0 for uncompressed)
          const headerStr = file.name + "|" + fileData.length + "|" + finalData.length + "|" + md5 + "|" + fileId + "|" + (compress ? "1" : "0");
          const headerPayload = new TextEncoder().encode(headerStr);
          const headerPacket = buildPacket(sender, receiver, 1, totalPackets, headerPayload, fileId);
          currentFilePackets.push(headerPacket);
          for (let i = 0; i < fileDataChunksCount; i++) {
            const start = i * 165;
            const end = Math.min(start + 165, finalData.length);
            const chunk = finalData.slice(start, end);
            const packet = buildPacket(sender, receiver, i + 2, totalPackets, chunk, fileId);
            currentFilePackets.push(packet);
          }
          currentPacketIndex = 0;
          currentRetries = 0;
          totalRetries = 0;
          fileTransferInProgress = true;
          sentFileStats = {
            fileName: file.name,
            receiver: receiver,
            originalSize: fileData.length,
            compressedSize: finalData.length,
            startTime: Date.now(),
            totalRetries: 0,
            bytesSent: 0,
            totalPackets: currentFilePackets.length,
            fileId: fileId
          };
          updateStatus(`File compressed from ${fileData.length} bytes to ${finalData.length} bytes.
                       Transfer will begin with a header packet containing file metadata, MD5 checksum, and compression flag.
                       File ID: ${fileId}`);
          updateSenderProgressUI();
          sendCurrentPacket(sender, receiver);
        };
        reader.onerror = function(e) {
          updateStatus("Error reading file: " + e);
        };
        reader.readAsArrayBuffer(file);
      });
      
      // (Optional) Fetch settings from /api/settings to pre-populate your callsign.
      fetch('/api/settings')
        .then(response => response.json())
        .then(settings => {
          document.getElementById('senderCallsign').value = settings.my_callsign;
        })
        .catch(error => {
          console.error("Error fetching settings:", error);
        });
      
    });
  </script>
</body>
</html>
